---
layout: default
title: Register Attendees
description: Setup a REST endpoint that accepts attendees' registration
lang: en
parent: Advanced Message Queuing Protocol
nav_order: 5
permalink: docs/amqp/register/
---

# Register Attendees
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Objectives

- [ ] Attendees cannot register to an event that does not exist
- [ ] Attendees cannot register to an expired event (event that happened in the past)
- [ ] Attendees should receive a confirmation following a successful registration

## Description

We need to add a new REST endpoint, `/event/{event-id}/register`, that accepts POST requests to register attendees.  The event id, in the form of [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier), will be part of the path, as shown next.

```
/event/47705b9b-518b-4dc2-a517-3dbbcab13fe7/register
```

The POST request will also have a body similar to the following example.

{% include custom/note.html details="The event id is not part of the request body, but only part of the request endpoint." %}

```json
{
  "name": "Aden Attard",
  "foodPreference": "VEGETARIAN"
}
```

In the above example, _Aden Attard_ submitted his registration for the event with id `47705b9b-518b-4dc2-a517-3dbbcab13fe7` and picked `VEGETARIAN` as his food of choice.

Following is a complete example of a request, using [CURL](https://curl.haxx.se/), that can be made to the REST endpoint **once this is created**.

```bash
$ curl \
 -H "content-type:application/json" \
 -X POST -d'{"name":"Aden Attard","foodPreference":"VEGETARIAN"}' \
 http://localhost:8080/event/47705b9b-518b-4dc2-a517-3dbbcab13fe7/register
```

The attendee should either receive a [`404`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404), meaning that the registration failed as the event does not exist or has expired.  If the registration succeeds, then the attendee should receive the registration id, similar to the following example.

```json
{
  "id": "248ed31c-35e3-4bd8-a36e-a5c27d3eb999"
}
```

The registration id is another UUID which is generated by the registration process.

## High-level design

The controller will receive the POST request from the attendee, will capture the information received from both the path variable and the request body and pass this as a single object to the service, as shown in the following sequence diagram.

![Contact-Us-Controller-Service-DB-Sequence-Diagram.png]({{ '/assets/images/Contact-Us-Controller-Service-DB-Sequence-Diagram.png' | absolute_url }})

The service will process the registration and will reply to the controller.  The controller will then parse the service response and responds to the attendee, either a `404` or the confirmation id, based on the response received from the service.  The following diagram shown next shows the objects exchanged between the controller and the service.

![Contact-Us-Controller-Service-Exchange-Of-Objects.png]({{ '/assets/images/Contact-Us-Controller-Service-Exchange-Of-Objects.png' | absolute_url }})

The service will use a repository to interact with the database.  The object that is received from the controller is mapped to an entity, which is then passed to the repository.  The service needs to first verify that the event exists and is not expired.  In these two cases, the service should simply return an empty optional.

We have two entities.
* Events
* Attendees

One or more attendees may attend an event.  We need to represent these into two tables, as shown next.

![One-Event-Many-Attendees.png]({{ '/assets/images/One-Event-Many-Attendees.png' | absolute_url }})

We can take advantage of JPA and use one repository to persist both the events and attendees entities.

## Controller

We will start from the frontend, the controller, and we will work our way back.

1. Create new `event` package

   ```bash
   $ mkdir src/main/java/demo/boot/event
   $ mkdir src/test/java/demo/boot/event
   $ mkdir src/test-integration/java/demo/boot/event
   ```

1. Create the controller

   Create file: `src/main/java/demo/boot/event/EventRegistrationController.java`

   ```java
   package demo.boot.event;

   import org.springframework.web.bind.annotation.RestController;

   @RestController
   public class EventRegistrationController {

   }
   ```

1. Create the controller test

   Create file: `src/test/java/demo/boot/event/EventRegistrationControllerTest.java`

   ```java
   package demo.boot.event;

   import org.junit.jupiter.api.DisplayName;
   import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;

   @DisplayName( "Registration controller" )
   @WebMvcTest( EventRegistrationController.class )
   public class EventRegistrationControllerTest {

   }
   ```

1. Test registration for an event that does not exist or has expired (happens in the past)

   {% include custom/note.html details="From the controller point-of-view expired events are treated the same as event not found.  The service will return an <a href='https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Optional.html#empty()'>empty optional</a> for both cases." %}

   Update file: `src/test/java/demo/boot/event/EventRegistrationControllerTest.java`

   {% include custom/dose_not_compile.html %}

   ```java
   package demo.boot.event;

   import com.fasterxml.jackson.databind.ObjectMapper;
   import org.junit.jupiter.api.DisplayName;
   import org.junit.jupiter.api.Test;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
   import org.springframework.boot.test.mock.mockito.MockBean;
   import org.springframework.http.MediaType;
   import org.springframework.test.web.servlet.MockMvc;

   import java.nio.charset.StandardCharsets;
   import java.util.Optional;
   import java.util.UUID;

   import static org.mockito.ArgumentMatchers.eq;
   import static org.mockito.Mockito.times;
   import static org.mockito.Mockito.verify;
   import static org.mockito.Mockito.verifyNoMoreInteractions;
   import static org.mockito.Mockito.when;
   import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
   import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

   @DisplayName( "Registration controller" )
   @WebMvcTest( EventRegistrationController.class )
   public class EventRegistrationControllerTest {

     @Autowired
     private MockMvc mockMvc;

     @MockBean
     private EventRegistrationService service;

     @Autowired
     private ObjectMapper jsonObjectMapper;

     @Test
     @DisplayName( "should return not found when registering for an event that does not exists" )
     public void shouldReturnNotFound() throws Exception {
       final UUID eventId = UUID.randomUUID();
       final String name = "Aden Attard";
       final FoodPreference foodPreference = FoodPreference.MEAT;
       final RegistrationRequest registrationRequest = new RegistrationRequest( name, foodPreference );
       final RegistrationDetails details = new RegistrationDetails( eventId, name, foodPreference );

       when( service.register( eq( details ) ) ).thenReturn( Optional.empty() );

       mockMvc
         .perform(
           post( "/event/{eventId}/register", eventId )
             .contentType( MediaType.APPLICATION_JSON )
             .characterEncoding( StandardCharsets.UTF_8.displayName() )
             .content( jsonObjectMapper.writeValueAsString( registrationRequest ) )
         )
         .andExpect( status().isNotFound() )
       ;

       verify( service, times( 1 ) ).register( details );
       verifyNoMoreInteractions( service );
     }
   }
   ```

   Make the test compile.

   1. Create file: `src/main/java/demo/boot/event/FoodPreference.java`

      ```java
      package demo.boot.event;

      public enum FoodPreference {
        NO_FOOD,
        VEGETARIAN,
        VEGAN,
        MEAT
      }
      ```

   1. Create file: `src/main/java/demo/boot/event/RegistrationDetails.java`

      ```java
      package demo.boot.event;

      import lombok.AllArgsConstructor;
      import lombok.Data;
      import lombok.NoArgsConstructor;

      import java.util.UUID;

      @Data
      @NoArgsConstructor
      @AllArgsConstructor
      public class RegistrationDetails {

        private UUID eventId;
        private String name;
        private FoodPreference foodPreference;
      }
      ```

   1. Create file: `src/main/java/demo/boot/event/RegistrationConfirmation.java`

      ```java
      package demo.boot.event;

      import lombok.AllArgsConstructor;
      import lombok.Data;
      import lombok.NoArgsConstructor;

      import java.util.UUID;

      @Data
      @NoArgsConstructor
      @AllArgsConstructor
      public class RegistrationConfirmation {

        private UUID id;
      }
      ```

   1. Create file: `src/main/java/demo/boot/event/EventRegistrationService.java`

      ```java
      package demo.boot.event;

      import java.util.Optional;

      public class EventRegistrationService {

        public Optional<RegistrationConfirmation> register( final RegistrationDetails registration ) {
          return Optional.empty();
        }
      }
      ```

   1. Create file: `src/main/java/demo/boot/event/RegistrationRequest.java`

      ```java
      package demo.boot.event;

      import lombok.AllArgsConstructor;
      import lombok.Data;
      import lombok.NoArgsConstructor;

      @Data
      @NoArgsConstructor
      @AllArgsConstructor
      public class RegistrationRequest {

        private String name;
        private FoodPreference foodPreference;
      }
      ```

   The test should now compile.  Run the test.

   ```bash
   $ ./gradlew clean test

   ...

   Registration controller > should return not found when registering for an event that does not exists FAILED
       org.mockito.exceptions.verification.WantedButNotInvoked at EventRegistrationControllerTest.java:58

   ...

   BUILD FAILED in 9s
   5 actionable tasks: 5 executed
   ```

   The test will fail, as expected.

   {% include custom/note.html details="The test had received a 404, as expected but the controller did not interact with the mocks as expected" %}

   ```bash
   $ open "build/reports/tests/test/classes/demo.boot.event.EventRegistrationControllerTest.html"
   ```

   ![Event-Registration-Controller-Test-shouldReturnNotFound.png]({{ '/assets/images/Event-Registration-Controller-Test-shouldReturnNotFound.png' | absolute_url }})

1. Make the test pass

   Update file: `src/main/java/demo/boot/event/EventRegistrationController.java`

   ```java
   package demo.boot.event;

   import lombok.AllArgsConstructor;
   import org.springframework.http.ResponseEntity;
   import org.springframework.web.bind.annotation.PathVariable;
   import org.springframework.web.bind.annotation.PostMapping;
   import org.springframework.web.bind.annotation.RequestBody;
   import org.springframework.web.bind.annotation.RestController;

   import java.util.UUID;

   @RestController
   @AllArgsConstructor
   public class EventRegistrationController {

     private final EventRegistrationService service;

     @PostMapping( "/event/{eventId}/register" )
     public ResponseEntity<RegistrationConfirmation> register(
       @PathVariable( "eventId" ) final UUID eventId,
       @RequestBody final RegistrationRequest request
     ) {
       final RegistrationDetails details =
         new RegistrationDetails( eventId, request.getName(), request.getFoodPreference() );

       service.register( details );
       return ResponseEntity.notFound().build();
     }
   }
   ```

   {% include custom/note.html details="Annotations are polluting the <code>register()</code> method." %}

   ```java
     @PostMapping( "/event/{eventId}/register" )                /* a */
     public ResponseEntity<RegistrationConfirmation> register(
       @PathVariable( "eventId" ) final UUID eventId,           /* b */
       @RequestBody final RegistrationRequest request           /* c */
     ) {
   ```

   1. Maps the `register()` method to our POST requests and defined the `{eventId}` path variable
   1. Extracts the `{eventId}` path variable into the method parameter, `eventId`
   1. Parse the POST request JSON body into `RegistrationRequest`

   Run the tests.

   ```bash
   $ ./gradlew clean test

   ...

   BUILD SUCCESSFUL in 7s
   5 actionable tasks: 5 executed
   ```

   All tests should now pass.

1. Test registration for an active event

   Update file: `src/test/java/demo/boot/event/EventRegistrationControllerTest.java`

   ```java
   package demo.boot.event;

   import com.fasterxml.jackson.databind.ObjectMapper;
   import org.junit.jupiter.api.DisplayName;
   import org.junit.jupiter.api.Test;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
   import org.springframework.boot.test.mock.mockito.MockBean;
   import org.springframework.http.MediaType;
   import org.springframework.test.web.servlet.MockMvc;

   import java.nio.charset.StandardCharsets;
   import java.util.Optional;
   import java.util.UUID;

   import static org.hamcrest.Matchers.is;
   import static org.mockito.ArgumentMatchers.eq;
   import static org.mockito.Mockito.times;
   import static org.mockito.Mockito.verify;
   import static org.mockito.Mockito.verifyNoMoreInteractions;
   import static org.mockito.Mockito.when;
   import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
   import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.header;
   import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
   import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

   @DisplayName( "Registration controller" )
   @WebMvcTest( EventRegistrationController.class )
   public class EventRegistrationControllerTest {

     @Autowired
     private MockMvc mockMvc;

     @MockBean
     private EventRegistrationService service;

     @Autowired
     private ObjectMapper jsonObjectMapper;

     @Test
     @DisplayName( "should return not found when registering for an event that does not exists" )
     public void shouldReturnNotFound() throws Exception { /* ... */ }

     @Test
     @DisplayName( "should return the registration confirmation when registering for an existing event" )
     public void shouldReturnConfirmation() throws Exception {
       final UUID eventId = UUID.randomUUID();
       final UUID confirmationId = UUID.randomUUID();
       final String name = "Jade Attard";
       final FoodPreference foodPreference = FoodPreference.MEAT;
       final RegistrationRequest registrationRequest = new RegistrationRequest( name, foodPreference );
       final RegistrationDetails details = new RegistrationDetails( eventId, name, foodPreference );

       when( service.register( eq( details ) ) ).thenReturn( Optional.of( new RegistrationConfirmation( confirmationId ) ) );

       mockMvc
         .perform(
           post( "/event/{eventId}/register", eventId )
             .contentType( MediaType.APPLICATION_JSON )
             .characterEncoding( StandardCharsets.UTF_8.displayName() )
             .content( jsonObjectMapper.writeValueAsString( registrationRequest ) )
         )
         .andExpect( status().isCreated() )
         .andExpect( header().string( "Location", String.format( "/event/registration/%s", confirmationId ) ) )
         .andExpect( jsonPath( "$" ).isMap() )
         .andExpect( jsonPath( "$.id", is( confirmationId.toString() ) ) )
       ;

       verify( service, times( 1 ) ).register( details );
       verifyNoMoreInteractions( service );
     }
   }
   ```

   Run the tests.

   ```bash
   $ ./gradlew clean test

   ...

   Registration controller > should return the registration confirmation when registering for an existing event FAILED
       java.lang.AssertionError at EventRegistrationControllerTest.java:84

   BUILD FAILED in 7s
   5 actionable tasks: 5 executed
   ```

   The test should fail.

1. Make the test pass

   Update file: `src/main/java/demo/boot/event/EventRegistrationController.java`

   ```java
   package demo.boot.event;

   import lombok.AllArgsConstructor;
   import org.springframework.http.ResponseEntity;
   import org.springframework.web.bind.annotation.PathVariable;
   import org.springframework.web.bind.annotation.PostMapping;
   import org.springframework.web.bind.annotation.RequestBody;
   import org.springframework.web.bind.annotation.RestController;

   import java.net.URI;
   import java.util.UUID;

   @RestController
   @AllArgsConstructor
   public class EventRegistrationController {

     private final EventRegistrationService service;

     @PostMapping( "/event/{eventId}/register" )
     public ResponseEntity<RegistrationConfirmation> register(
       @PathVariable( "eventId" ) final UUID eventId,
       @RequestBody final RegistrationRequest request
     ) {
       final RegistrationDetails details =
         new RegistrationDetails( eventId, request.getName(), request.getFoodPreference() );

       return service
         .register( details )
         .map( confirmation -> ResponseEntity
           .created( URI.create( String.format( "/event/registration/%s", confirmation.getId() ) ) )
           .body( confirmation ) )
         .orElse( ResponseEntity.notFound().build() );
     }
   }
   ```

   Run the tests.

   ```bash
   $ ./gradlew clean test

   ...

   BUILD SUCCESSFUL in 8s
   5 actionable tasks: 5 executed
   ```

   The test should pass.

1. Refactor the controller

   Update file: `src/main/java/demo/boot/event/EventRegistrationController.java`

   ```java
   package demo.boot.event;

   import lombok.AllArgsConstructor;
   import org.springframework.http.ResponseEntity;
   import org.springframework.web.bind.annotation.PathVariable;
   import org.springframework.web.bind.annotation.PostMapping;
   import org.springframework.web.bind.annotation.RequestBody;
   import org.springframework.web.bind.annotation.RestController;

   import java.net.URI;
   import java.util.UUID;

   @RestController
   @AllArgsConstructor
   public class EventRegistrationController {

     private static final ResponseEntity<RegistrationConfirmation> NOT_FOUND = ResponseEntity.notFound().build();

     private final EventRegistrationService service;

     @PostMapping( "/event/{eventId}/register" )
     public ResponseEntity<RegistrationConfirmation> register(
       @PathVariable( "eventId" ) final UUID eventId,
       @RequestBody final RegistrationRequest request
     ) {
       final RegistrationDetails details =
         new RegistrationDetails( eventId, request.getName(), request.getFoodPreference() );

       return service
         .register( details )
         .map( this::mapToResponse )
         .orElse( NOT_FOUND );
     }

     private ResponseEntity<RegistrationConfirmation> mapToResponse( final RegistrationConfirmation confirmation ) {
       return ResponseEntity
         .created( createLocationHeader( confirmation ) )
         .body( confirmation );
     }

     private URI createLocationHeader( final RegistrationConfirmation confirmation ) {
       return URI.create( String.format( "/event/registration/%s", confirmation.getId() ) );
     }
   }
   ```

The controller is complete.  It parses the request into Java objects and invokes the service and then reply to the attendee based on the service's response.

## Service

The controller is ready, and the service is next in line.

1. Create test class

   Create file: `src/test/java/demo/boot/event/EventRegistrationServiceTest.java`

   ```java
   package demo.boot.event;

   import org.junit.jupiter.api.DisplayName;

   @DisplayName( "Event registration service" )
   public class EventRegistrationServiceTest {

   }
   ```

1. Test registration for an event that does not exist

   {% include custom/note.html details="The service needs two tests to cover events that do not exist and expired events.  In the latter, the repository will return an optional with the expired entity, while in the former case the repository will return an empty optional." %}

   Update file: `src/test/java/demo/boot/event/EventRegistrationServiceTest.java`

   {% include custom/dose_not_compile.html %}

   ```java
   package demo.boot.event;

   import org.junit.jupiter.api.DisplayName;
   import org.junit.jupiter.api.Test;

   import java.util.Optional;
   import java.util.UUID;

   import static org.junit.jupiter.api.Assertions.assertEquals;
   import static org.mockito.ArgumentMatchers.eq;
   import static org.mockito.Mockito.mock;
   import static org.mockito.Mockito.times;
   import static org.mockito.Mockito.verify;
   import static org.mockito.Mockito.verifyNoMoreInteractions;
   import static org.mockito.Mockito.when;

   @DisplayName( "Event registration service" )
   public class EventRegistrationServiceTest {

     @Test
     @DisplayName( "should return Optional empty when registering to an non existing event" )
     public void shouldReturnOptionalEmptyWhenNotFound() {
       final EventRepository eventRepository = mock( EventRepository.class );

       final UUID eventId = UUID.randomUUID();
       final String name = "Albert Attard";
       final FoodPreference foodPreference = FoodPreference.MEAT;
       final RegistrationDetails details = new RegistrationDetails( eventId, name, foodPreference );

       when( eventRepository.findById( eq( eventId ) ) ).thenReturn( Optional.empty() );

       final EventRegistrationService service = new EventRegistrationService( eventRepository );
       final Optional<RegistrationConfirmation> confirmation = service.register( details );
       assertEquals( Optional.empty(), confirmation );

       verify( eventRepository, times( 1 ) ).findById( eventId );
       verifyNoMoreInteractions( eventRepository );
     }
   }
   ```

   Make the test compile.

   1. Create file: `src/main/java/demo/boot/event/EventRepository.java`

      {% include custom/note.html details="We are using an <code>Object</code> (<code>extends JpaRepository&lt;Object, UUID&gt;</code>) and not our entity, which is not yet created.  We will replace this with a proper entity class later on.  We are taking this approach as we want to test the service with the bare minimum code.  Entities will be added and enhances in later stages." %}

      ```java
      package demo.boot.event;

      import org.springframework.data.jpa.repository.JpaRepository;

      import java.util.UUID;

      public interface EventRepository extends JpaRepository<Object, UUID> {
      }
      ```

   1. Update file: `src/main/java/demo/boot/event/EventRegistrationService.java`

      ```java
      package demo.boot.event;

      import lombok.AllArgsConstructor;

      import java.util.Optional;

      @AllArgsConstructor
      public class EventRegistrationService {

        private final EventRepository repository;

        public Optional<RegistrationConfirmation> register( final RegistrationDetails registration ) {
          return Optional.empty();
        }
      }
      ```

   The test should now compile.  Run the test.

   ```bash
   $ ./gradlew clean test

   ...

   Event registration service > should return Optional empty when registering to a non existing event FAILED
       org.mockito.exceptions.verification.WantedButNotInvoked at EventRegistrationServiceTest.java:36

   ...

   BUILD FAILED in 9s
   5 actionable tasks: 5 executed
   ```

   The test will fail, as expected.

1. Make the test pass

   Update file: `src/main/java/demo/boot/event/EventRegistrationService.java`

   {% include custom/note.html details="The following example is just enough to make the test pass." %}

   ```java
   package demo.boot.event;

   import lombok.AllArgsConstructor;

   import java.util.Optional;

   @AllArgsConstructor
   public class EventRegistrationService {

     private final EventRepository repository;

     public Optional<RegistrationConfirmation> register( final RegistrationDetails registration ) {
       repository.findById( registration.getEventId() );
       return Optional.empty();
     }
   }
   ```

   Run the tests.

   ```bash
   ./gradlew clean test

   ...

   BUILD SUCCESSFUL in 7s
   5 actionable tasks: 5 executed
   ```

   All tests should now pass.

1. Test registration for an expired event

   Update file: `src/test/java/demo/boot/event/EventRegistrationServiceTest.java`

   ```java
   package demo.boot.event;

   import org.junit.jupiter.api.DisplayName;
   import org.junit.jupiter.api.Test;

   import java.time.LocalDate;
   import java.util.Optional;
   import java.util.UUID;

   import static org.junit.jupiter.api.Assertions.assertEquals;
   import static org.mockito.ArgumentMatchers.eq;
   import static org.mockito.Mockito.mock;
   import static org.mockito.Mockito.times;
   import static org.mockito.Mockito.verify;
   import static org.mockito.Mockito.verifyNoMoreInteractions;
   import static org.mockito.Mockito.when;

   @DisplayName( "Event registration service" )
   public class EventRegistrationServiceTest {

     @Test
     @DisplayName( "should return Optional empty when registering to an non existing event" )
     public void shouldReturnOptionalEmptyWhenNotFound() { /* ... */ }

     @Test
     @DisplayName( "should return Optional empty when registering to an expired event" )
     public void shouldReturnOptionalEmptyWhenExpired() {
       final EventRepository eventRepository = mock( EventRepository.class );
       final EventEntity eventEntity = mock( EventEntity.class );

       final UUID eventId = UUID.randomUUID();
       final String name = "Jade Attard";
       final FoodPreference foodPreference = FoodPreference.VEGETARIAN;
       final RegistrationDetails details = new RegistrationDetails( eventId, name, foodPreference );

       when( eventRepository.findById( eq( eventId ) ) ).thenReturn( Optional.of( eventEntity ) );
       when( eventEntity.getDate() ).thenReturn( LocalDate.now().minusDays( 1 ) );

       final EventRegistrationService service = new EventRegistrationService( eventRepository );
       final Optional<RegistrationConfirmation> confirmation = service.register( details );
       assertEquals( Optional.empty(), confirmation );

       verify( eventRepository, times( 1 ) ).findById( eventId );
       verify( eventEntity, times( 1 ) ).getDate();
       verifyNoMoreInteractions( eventRepository, eventEntity );
     }
   }
   ```

   Make the test compile.

   1. Create file: `src/main/java/demo/boot/event/EventEntity.java`

      {% include custom/note.html details="While the following class will be used as an entity, we are not yet using and JPA annotations.  We do not need these annotations yet and our service can work well without these annotations.  We will implement them when we cover the <a href='#repository'>repository</a>." %}

      ```java
      package demo.boot.event;

      import lombok.Data;

      import java.time.LocalDate;

      @Data
      public class EventEntity {

        private LocalDate date;
      }
      ```

   1. Update file: `src/main/java/demo/boot/event/EventRepository.java`

      ```java
      package demo.boot.event;

      import org.springframework.data.jpa.repository.JpaRepository;

      import java.util.UUID;

      public interface EventRepository extends JpaRepository<EventEntity, UUID> {
      }
      ```

   The test should now compile. Run the test.

   ```bash
   $ ./gradlew clean test

   ...

   Event registration service > should return Optional empty when registering to an expired event FAILED
       org.mockito.exceptions.verification.WantedButNotInvoked at EventRegistrationServiceTest.java:60

   ...

   BUILD FAILED in 9s
   5 actionable tasks: 5 executed
   ```

   As expected, the test should fail

1. Make the test pass

   Update file: `src/main/java/demo/boot/event/EventRegistrationService.java`

   {% include custom/note.html details="The following example simply makes the test pass.  Later on, we make good use of the event date.  We are taking this approach so that we only include the bare minimum required just to make the test pass." %}

   ```java
   package demo.boot.event;

   import lombok.AllArgsConstructor;

   import java.util.Optional;

   @AllArgsConstructor
   public class EventRegistrationService {

     private final EventRepository repository;

     public Optional<RegistrationConfirmation> register( final RegistrationDetails registration ) {
       repository
         .findById( registration.getEventId() )
         .ifPresent( EventEntity::getDate )
       ;
       return Optional.empty();
     }
   }
   ```

   Run the tests.

   ```bash
   $ ./gradlew clean test

   ...

   BUILD SUCCESSFUL in 7s
   5 actionable tasks: 5 executed
   ```

   All tests should now pass.

1. Test registration for an active event

   Update file: `src/test/java/demo/boot/event/EventRegistrationServiceTest.java`

   {% include custom/note.html details="The new test is more complex than the previous two and introduces new classes." %}

   ```java
   package demo.boot.event;

   import org.junit.jupiter.api.DisplayName;
   import org.junit.jupiter.api.Test;

   import java.time.LocalDate;
   import java.util.Optional;
   import java.util.UUID;

   import static org.junit.jupiter.api.Assertions.assertEquals;
   import static org.junit.jupiter.api.Assertions.assertTrue;
   import static org.mockito.ArgumentMatchers.eq;
   import static org.mockito.Mockito.doNothing;
   import static org.mockito.Mockito.mock;
   import static org.mockito.Mockito.times;
   import static org.mockito.Mockito.verify;
   import static org.mockito.Mockito.verifyNoMoreInteractions;
   import static org.mockito.Mockito.when;

   @DisplayName( "Event registration service" )
   public class EventRegistrationServiceTest {

     @Test
     @DisplayName( "should return Optional empty when registering to an non existing event" )
     public void shouldReturnOptionalEmptyWhenNotFound() { /* ... */ }

     @Test
     @DisplayName( "should return Optional empty when registering to an expired event" )
     public void shouldReturnOptionalEmptyWhenExpired() { /* ... */ }

     @Test
     @DisplayName( "should return the registration confirmation when registering to an active event" )
     public void shouldReturnConfirmationWhenActive() {
       final EventRepository eventRepository = mock( EventRepository.class );
       final EventEntity eventEntity = mock( EventEntity.class );
       final UuidGeneratorService uuidGeneratorService = mock( UuidGeneratorService.class );

       final UUID eventId = UUID.randomUUID();
       final UUID attendeeId = UUID.randomUUID();
       final String name = "Aden Attard";
       final FoodPreference foodPreference = FoodPreference.VEGAN;
       final RegistrationDetails details = new RegistrationDetails( eventId, name, foodPreference );
       final EventAttendeeEntity attendeeEntity = new EventAttendeeEntity( attendeeId, name, foodPreference, eventEntity );

       when( eventRepository.findById( eq( eventId ) ) ).thenReturn( Optional.of( eventEntity ) );
       when( eventEntity.getDate() ).thenReturn( LocalDate.now().plusDays( 1 ) );
       when( uuidGeneratorService.nextAttendeeId() ).thenReturn( attendeeId );
       doNothing().when( eventEntity ).addAttendee( attendeeEntity );
       when( eventRepository.save( eq( eventEntity ) ) ).thenReturn( eventEntity );

       final EventRegistrationService service = new EventRegistrationService( eventRepository );
       final Optional<RegistrationConfirmation> confirmation = service.register( details );
       assertEquals( Optional.of( new RegistrationConfirmation( attendeeId ) ), confirmation );

       verify( eventRepository, times( 1 ) ).findById( eventId );
       verify( eventEntity, times( 1 ) ).getDate();
       verify( uuidGeneratorService, times( 1 ) ).nextAttendeeId();
       verify( eventEntity, times( 1 ) ).addAttendee( attendeeEntity );
       verify( eventRepository, times( 1 ) ).save( eventEntity );
       verifyNoMoreInteractions( eventRepository, eventEntity, uuidGeneratorService );
     }
   }
   ```

   This test is more complicated than the previous two.  When we register a new attendee, we need to create a new entity object (of type `EventAttendeeEntity`) and also create an id (of type `UUID`).  If we create this id from within the service's `register()` method, then we will have no way to ascertain that the right objects are used and passed around.

   For example, our test ascertains that the correct `` is returned.

   ```java
       assertEquals( Optional.of( new RegistrationConfirmation( attendeeId ) ), confirmation );
   ```

   The above assertion would not be possible if we create the id from within the service's `register()` method.  To address this problem, we need to have a new service that generates the ids for us.  Having a service that provides this, we can mock the service and control its behaviour for our tests.

   Make the test compile.

   1. Create file: `src/main/java/demo/boot/event/UuidGeneratorService.java`

      ```java
      package demo.boot.event;

      import java.util.UUID;

      public class UuidGeneratorService {
        public UUID nextAttendeeId() {
          return UUID.randomUUID();
        }
      }
      ```

      While it is highly improbable to produce the same UUID twice, it is important to check that our UUIDs are unique and once produces, we are certain that these UUIDs are not reproduced/reused.  We can do that by saving all generated UUIDs in a dedicated table, such as `generated_ids`, and check with the table before returning the newly generated UUID.  This will ensure that an UUID is only generated once and never reused.

      We are not doing checking for uniqueness in this example, for simplicity.

   1. Create file: `src/main/java/demo/boot/event/EventAttendeeEntity.java`

      {% include custom/note.html details="While the following class will be used as an entity, we are not yet using and JPA annotations.  We do not need these annotations yet and our service can work well without these annotations.  We will implement them when we cover the <a href='#repository'>repository</a>." %}

      ```java
      package demo.boot.event;

      import lombok.AllArgsConstructor;
      import lombok.Data;
      import lombok.NoArgsConstructor;

      import java.util.UUID;

      @Data
      @NoArgsConstructor
      @AllArgsConstructor
      public class EventAttendeeEntity {

        private UUID id;
        private String name;
        private FoodPreference foodPreference;
        private EventEntity event;
      }
      ```

   1. Update file: `src/main/java/demo/boot/event/EventEntity.java`

      {% include custom/note.html details="We do not need to add functionality to the <code>addAttendee()</code> method.  We will implement this method when we cover the <a href='#repository'>repository</a>." %}

      ```java
      package demo.boot.event;

      import lombok.Data;

      import java.time.LocalDate;

      @Data
      public class EventEntity {

        private LocalDate date;

        public void addAttendee( final EventAttendeeEntity attendee ) {
          /* TODO: Implement */
        }
      }
      ```

   The test should now compile. Run the test.

   ```bash
   $ ./gradlew clean test

   ...

   Event registration service > should return the registration confirmation when registering to an active event FAILED
       org.opentest4j.AssertionFailedError at EventRegistrationServiceTest.java:87

   ...

   BUILD FAILED in 7s
   5 actionable tasks: 5 executed
   ```

   The test will fail, as expected.

1. Make the test pass

   This test requires a long and complicated change.  We will do it in several iterations.  Most of the changes shown next apply to the same file, `src/main/java/demo/boot/event/EventRegistrationService.java`.

   1. Filter expired events.

      Update file: `src/main/java/demo/boot/event/EventRegistrationService.java`

      Replace

      ```java
            .ifPresent( EventEntity::getDate )
      ```

      with

      ```java
            .filter( event -> LocalDate.now().isBefore( event.getDate() ) )
      ```

      Following is the complete example.

      ```java
      package demo.boot.event;

      import lombok.AllArgsConstructor;

      import java.time.LocalDate;
      import java.util.Optional;

      @AllArgsConstructor
      public class EventRegistrationService {

        private final EventRepository repository;

        public Optional<RegistrationConfirmation> register( final RegistrationDetails registration ) {
          repository
            .findById( registration.getEventId() )
      /**/  .filter( event -> LocalDate.now().isBefore( event.getDate() ) )
          ;
          return Optional.empty();
        }
      }
      ```

      Run the tests.  **The same tests should fail**.

   1. Create new entity.

      Update file: `src/main/java/demo/boot/event/EventRegistrationService.java`

      ```java
      package demo.boot.event;

      import lombok.AllArgsConstructor;

      import java.time.LocalDate;
      import java.util.Optional;

      @AllArgsConstructor
      public class EventRegistrationService {

        private final EventRepository repository;

        public Optional<RegistrationConfirmation> register( final RegistrationDetails registration ) {
          repository
            .findById( registration.getEventId() )
            .filter( event -> LocalDate.now().isBefore( event.getDate() ) )
      /**/  .map( event -> {
      /**/    final EventAttendeeEntity attendee = new EventAttendeeEntity();
      /**/    // attendee.setId(  ); /* TODO: we need to get this from a service */
      /**/    attendee.setName( registration.getName() );
      /**/    attendee.setFoodPreference( registration.getFoodPreference() );
      /**/    attendee.setEvent( event );
      /**/    event.addAttendee( attendee );
      /**/    /* TODO: Save event through the repository */
      /**/    return attendee;
      /**/  } );
          ;
          return Optional.empty();
        }
      }
      ```

      The above change requires the id service, which we do not have here yet.  Run the tests and confirm that the same test fail, while all other tests still pass.

   1. Use the `UuidGeneratorService` service

      We need to modify two files this time.

      Update file: `src/main/java/demo/boot/event/EventRegistrationService.java`

      {% include custom/project_dose_not_compile.html %}

      Add the property

      ```java
        private final UuidGeneratorService uuidGeneratorService;
      ```

      Following is the complete example.

      ```java
      package demo.boot.event;

      import lombok.AllArgsConstructor;

      import java.time.LocalDate;
      import java.util.Optional;

      @AllArgsConstructor
      public class EventRegistrationService {

        private final EventRepository repository;
      /**/private final UuidGeneratorService uuidGeneratorService;

        public Optional<RegistrationConfirmation> register( final RegistrationDetails registration ) { /* ... */ }
      }
      ```

      The above change will break our test class, `EventRegistrationServiceTest`

      Add the new service, `UuidGeneratorService`, to the `EventRegistrationService` constructor.  This effect all three tests.  Furthermore, the `UuidGeneratorService` mock is missing in the first two tests, which needs to be added.

      Update file: `src/test/java/demo/boot/event/EventRegistrationServiceTest.java`

      ```java
      package demo.boot.event;

      import org.junit.jupiter.api.DisplayName;
      import org.junit.jupiter.api.Test;

      import java.time.LocalDate;
      import java.util.Optional;
      import java.util.UUID;

      import static org.junit.jupiter.api.Assertions.assertEquals;
      import static org.mockito.ArgumentMatchers.eq;
      import static org.mockito.Mockito.doNothing;
      import static org.mockito.Mockito.mock;
      import static org.mockito.Mockito.times;
      import static org.mockito.Mockito.verify;
      import static org.mockito.Mockito.verifyNoMoreInteractions;
      import static org.mockito.Mockito.when;

      @DisplayName( "Event registration service" )
      public class EventRegistrationServiceTest {

        @Test
        @DisplayName( "should return Optional empty when registering to an non existing event" )
        public void shouldReturnOptionalEmptyWhenNotFound() {
          final EventRepository eventRepository = mock( EventRepository.class );
      /**/final UuidGeneratorService uuidGeneratorService = mock( UuidGeneratorService.class );

          final UUID eventId = UUID.randomUUID();
          final String name = "Aden Attard";
          final FoodPreference foodPreference = FoodPreference.MEAT;
          final RegistrationDetails details = new RegistrationDetails( eventId, name, foodPreference );

          when( eventRepository.findById( eq( eventId ) ) ).thenReturn( Optional.empty() );

      /**/final EventRegistrationService service = new EventRegistrationService( eventRepository, uuidGeneratorService );
          final Optional<RegistrationConfirmation> confirmation = service.register( details );
          assertEquals( Optional.empty(), confirmation );

          verify( eventRepository, times( 1 ) ).findById( eventId );
      /**/verifyNoMoreInteractions( eventRepository, uuidGeneratorService );
        }

        @Test
        @DisplayName( "should return Optional empty when registering to an expired event" )
        public void shouldReturnOptionalEmptyWhenExpired() {
          final EventRepository eventRepository = mock( EventRepository.class );
          final EventEntity eventEntity = mock( EventEntity.class );
      /**/final UuidGeneratorService uuidGeneratorService = mock( UuidGeneratorService.class );

          final UUID eventId = UUID.randomUUID();
          final String name = "Jade Attard";
          final FoodPreference foodPreference = FoodPreference.VEGETARIAN;
          final RegistrationDetails details = new RegistrationDetails( eventId, name, foodPreference );

          when( eventRepository.findById( eq( eventId ) ) ).thenReturn( Optional.of( eventEntity ) );
          when( eventEntity.getDate() ).thenReturn( LocalDate.now().minusDays( 1 ) );

      /**/final EventRegistrationService service = new EventRegistrationService( eventRepository, uuidGeneratorService );
          final Optional<RegistrationConfirmation> confirmation = service.register( details );
          assertEquals( Optional.empty(), confirmation );

          verify( eventRepository, times( 1 ) ).findById( eventId );
          verify( eventEntity, times( 1 ) ).getDate();
      /**/verifyNoMoreInteractions( eventRepository, eventEntity, uuidGeneratorService );
        }

        @Test
        @DisplayName( "should return the registration confirmation when registering to an active event" )
        public void shouldReturnConfirmationWhenActive() {
          final EventRepository eventRepository = mock( EventRepository.class );
          final EventEntity eventEntity = mock( EventEntity.class );
          final UuidGeneratorService uuidGeneratorService = mock( UuidGeneratorService.class );

          final UUID eventId = UUID.randomUUID();
          final UUID attendeeId = UUID.randomUUID();
          final String name = "Aden Attard";
          final FoodPreference foodPreference = FoodPreference.VEGAN;
          final RegistrationDetails details = new RegistrationDetails( eventId, name, foodPreference );
          final EventAttendeeEntity attendeeEntity = new EventAttendeeEntity( attendeeId, name, foodPreference, eventEntity );

          when( eventRepository.findById( eq( eventId ) ) ).thenReturn( Optional.of( eventEntity ) );
          when( eventEntity.getDate() ).thenReturn( LocalDate.now().plusDays( 1 ) );
          when( uuidGeneratorService.nextAttendeeId() ).thenReturn( attendeeId );
          doNothing().when( eventEntity ).addAttendee( attendeeEntity );
          when( eventRepository.save( eq( eventEntity ) ) ).thenReturn( eventEntity );

      /**/final EventRegistrationService service = new EventRegistrationService( eventRepository, uuidGeneratorService );
          final Optional<RegistrationConfirmation> confirmation = service.register( details );
          assertEquals( Optional.of( new RegistrationConfirmation( attendeeId ) ), confirmation );

          verify( eventRepository, times( 1 ) ).findById( eventId );
          verify( eventEntity, times( 1 ) ).getDate();
          verify( uuidGeneratorService, times( 1 ) ).nextAttendeeId();
          verify( eventEntity, times( 1 ) ).addAttendee( attendeeEntity );
          verify( eventRepository, times( 1 ) ).save( eventEntity );
          verifyNoMoreInteractions( eventRepository, eventEntity, uuidGeneratorService );
        }
      }
      ```

      The project should now compile.  Run the tests again.  The same test is still expected to fail.

   1. Generate the attendee id

      Update file: `src/main/java/demo/boot/event/EventRegistrationService.java`

      ```java
      package demo.boot.event;

      import lombok.AllArgsConstructor;

      import java.time.LocalDate;
      import java.util.Optional;

      @AllArgsConstructor
      public class EventRegistrationService {

        private final EventRepository repository;
        private final UuidGeneratorService uuidGeneratorService;

        public Optional<RegistrationConfirmation> register( final RegistrationDetails registration ) {
          repository
            .findById( registration.getEventId() )
            .filter( event -> LocalDate.now().isBefore( event.getDate() ) )
            .map( event -> {
              final EventAttendeeEntity attendee = new EventAttendeeEntity();
      /**/    attendee.setId( uuidGeneratorService.nextAttendeeId() );
              attendee.setName( registration.getName() );
              attendee.setFoodPreference( registration.getFoodPreference() );
              attendee.setEvent( event );
              event.addAttendee( attendee );
              /* TODO: Save event through the repository */
              return attendee;
            } );
          ;
          return Optional.empty();
        }
      }
      ```

      Run the tests again.  The same test is still expected to fail.

   1. Return the confirmation

      Update file: `src/main/java/demo/boot/event/EventRegistrationService.java`

      ```java
      package demo.boot.event;

      import lombok.AllArgsConstructor;

      import java.time.LocalDate;
      import java.util.Optional;

      @AllArgsConstructor
      public class EventRegistrationService {

        private final EventRepository repository;
        private final UuidGeneratorService uuidGeneratorService;

        public Optional<RegistrationConfirmation> register( final RegistrationDetails registration ) {
      /**/return repository
            .findById( registration.getEventId() )
            .filter( event -> LocalDate.now().isBefore( event.getDate() ) )
            .map( event -> {
              final EventAttendeeEntity attendee = new EventAttendeeEntity();
              attendee.setId( uuidGeneratorService.nextAttendeeId() );
              attendee.setName( registration.getName() );
              attendee.setFoodPreference( registration.getFoodPreference() );
              attendee.setEvent( event );
              event.addAttendee( attendee );
              /* TODO: Save event through the repository */
              return attendee;
            } )
      /**/  .map( attendee -> new RegistrationConfirmation( attendee.getId() ) )
            ;
      /* DELETE: return Optional.empty(); */
        }
      }
      ```

      Our implementation is now returning the confirmation together with the generated attendee id.  The same test should still fail as we are not saving the event yet.

   1. Save the event

      Update file: `src/main/java/demo/boot/event/EventRegistrationService.java`

      ```java
      package demo.boot.event;

      import lombok.AllArgsConstructor;

      import java.time.LocalDate;
      import java.util.Optional;

      @AllArgsConstructor
      public class EventRegistrationService {

        private final EventRepository repository;
        private final UuidGeneratorService uuidGeneratorService;

        public Optional<RegistrationConfirmation> register( final RegistrationDetails registration ) {
          return repository
            .findById( registration.getEventId() )
            .filter( event -> LocalDate.now().isBefore( event.getDate() ) )
            .map( event -> {
              final EventAttendeeEntity attendee = new EventAttendeeEntity();
              attendee.setId( uuidGeneratorService.nextAttendeeId() );
              attendee.setName( registration.getName() );
              attendee.setFoodPreference( registration.getFoodPreference() );
              attendee.setEvent( event );
              event.addAttendee( attendee );
      /**/    repository.save( event );
              return attendee;
            } )
            .map( attendee -> new RegistrationConfirmation( attendee.getId() ) )
            ;
        }
      }
      ```

      Our service is finally complete.  Run the test.

      {% include custom/note.html details="We are only running the tests and not the integration tests.  The integration will fail as we have not yet properly implemented the <a href='#repository'>repository</a> and annotated our newly created services." %}

      ```bash
      $ ./gradlew clean test

      ...

      BUILD SUCCESSFUL in 13s
      5 actionable tasks: 5 executed
      ```

The service is for now complete.  It retrieves the event from the repository and if an active event exists then it creates a new attendee.  Finally, it returns the confirmation back to the caller, in our case the [controller](#controller).

## Repository

With the [controller](#controller) and [service](#service) ready, we turn our attention on the last part of the puzzle, the repository.

1. Create the database migration script

   Create file: `src/main/resources/db/migration/V3__create_events_and_attendees_tables.sql`

   {% include custom/note.html details="The following migraiton script adds an event which is used later on.  Please make sure that the event id, <code>47705b9b-518b-4dc2-a517-3dbbcab13fe7</code>, is not changed." %}

   ```sql
   CREATE TABLE "events" (
     "id"          UUID PRIMARY KEY,
     "office"      VARCHAR(255) NOT NULL,
     "date"        DATE NOT NULL,
     "caption"     VARCHAR(64),
     "description" VARCHAR(255)
   );

   CREATE TABLE "events_attendees" (
     "id"               UUID PRIMARY KEY,
     "event"            UUID NOT NULL,
     "name"             VARCHAR(64),
     "food_preference"  VARCHAR(64)
   );

   INSERT INTO "events" ("id","office","date","caption","description") VALUES ('47705b9b-518b-4dc2-a517-3dbbcab13fe7','ThoughtWorks Cologne','2077-04-27','Spring Boot','Deep Dive into Spring Boot technologies');
   ```

   The above [Flyway migration script](https://flywaydb.org/documentation/migrations) creates two tables and adds an event to the events table.

   **Why are we not using foreign keys?**

   Foreign keys will ensure that our data is consisted event at the database level.  Foreign keys were not used here for simplicity.  Furthermore, adding foreign keys will not require any changed to the code.  If you feel bold, please refer to the [PostgreSQL documentation](https://www.postgresql.org/docs/9.2/ddl-constraints.html#DDL-CONSTRAINTS-FK) to see how use foreign keys.

1. Create

   Create file: `src/test-integration/java/demo/boot/event/EventRepositoryTest.java`

   ```java
   package demo.boot.event;

   import org.junit.jupiter.api.DisplayName;
   import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
   import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;

   @DataJpaTest
   @DisplayName( "Event repository" )
   @AutoConfigureTestDatabase( replace = AutoConfigureTestDatabase.Replace.NONE )
   public class EventRepositoryTest {

   }
   ```

1. Test

   Update file: `src/test-integration/java/demo/boot/event/EventRepositoryTest.java`

   ```java
   package demo.boot.event;

   import org.junit.jupiter.api.DisplayName;
   import org.junit.jupiter.api.Test;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
   import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;

   import java.util.Optional;
   import java.util.UUID;

   import static org.assertj.core.api.Assertions.assertThat;

   @DataJpaTest
   @DisplayName( "Event repository" )
   @AutoConfigureTestDatabase( replace = AutoConfigureTestDatabase.Replace.NONE )
   public class EventRepositoryTest {

     @Autowired
     private EventRepository repository;

     @Test
     @DisplayName( "should return the hard coded event" )
     public void shouldReturnAll() {
       final UUID eventId = UUID.fromString( "47705b9b-518b-4dc2-a517-3dbbcab13fe7" );
       final Optional<EventEntity> optional = repository.findById( eventId );
       assertThat( optional.isPresent() ).isTrue();
     }
   }
   ```

   ```bash
   $ ./gradlew clean integrationTest "--tests" "*EventRepositoryTest"

   ...

   Event repository > should return the hard coded event FAILED
       org.springframework.beans.factory.BeanCreationException at EventRepositoryTest.java:25

   ...

   BUILD FAILED in 8s
   6 actionable tasks: 6 executed
   ```

   ```bash
   $ open "build/reports/tests/integrationTest/classes/demo.boot.event.EventRepositoryTest.html"
   ```

   ```bash
   ...
   Caused by: java.lang.IllegalArgumentException: Not a managed type: class demo.boot.event.EventEntity
   	 at org.hibernate.metamodel.internal.MetamodelImpl.managedType(MetamodelImpl.java:582)
   	 at org.hibernate.metamodel.internal.MetamodelImpl.managedType(MetamodelImpl.java:85)
   ...
   ```

1. Entity

   Update file: `src/main/java/demo/boot/event/EventEntity.java`

   ```java
   package demo.boot.event;

   import lombok.Data;

   import javax.persistence.Entity;
   import javax.persistence.Id;
   import javax.persistence.Table;
   import java.time.LocalDate;
   import java.util.UUID;

   @Data
   /**/@Entity
   /**/@Table( name = "events" )
   public class EventEntity {

   /**/@Id
   /**/private UUID id;
     private LocalDate date;

     public void addAttendee( final EventAttendeeEntity attendee ) {
     }
   }
   ```

   ```bash
   $ ./gradlew clean integrationTest "--tests" "*EventRepositoryTest"

   ...

   BUILD SUCCESSFUL in 16s
   6 actionable tasks: 6 executed
   ```

1. Link to office

   Update file: `src/test-integration/java/demo/boot/event/EventRepositoryTest.java`

   {% include custom/dose_not_compile.html %}

   ```java
   package demo.boot.event;

   import demo.boot.office.OfficeEntity;
   import org.junit.jupiter.api.DisplayName;
   import org.junit.jupiter.api.Test;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
   import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;

   import java.util.Optional;
   import java.util.UUID;

   import static org.assertj.core.api.Assertions.assertThat;

   @DataJpaTest
   @DisplayName( "Event repository" )
   @AutoConfigureTestDatabase( replace = AutoConfigureTestDatabase.Replace.NONE )
   public class EventRepositoryTest {

     @Autowired
     private EventRepository repository;

   /**/private static final OfficeEntity COLOGNE = new OfficeEntity(
   /**/  "ThoughtWorks Cologne",
   /**/  "Lichtstr. 43i, 50825 Cologne, Germany",
   /**/  "Germany",
   /**/  "+49 221 64 30 70 63",
   /**/  "contact-de@thoughtworks.com",
   /**/  "https://www.thoughtworks.com/locations/cologne"
   /**/);

     @Test
     @DisplayName( "should return the hard coded event" )
     public void shouldReturnAll() {
       final UUID eventId = UUID.fromString( "47705b9b-518b-4dc2-a517-3dbbcab13fe7" );
       final Optional<EventEntity> optional = repository.findById( eventId );
       assertThat( optional.isPresent() ).isTrue();

   /**/final EventEntity entity = optional.get();
   /**/assertThat( entity.getOffice() ).isEqualTo( COLOGNE );
     }
   }
   ```

   Update file: `src/main/java/demo/boot/event/EventEntity.java`

   ```java
   package demo.boot.event;

   import demo.boot.office.OfficeEntity;
   import lombok.Data;

   import javax.persistence.Entity;
   import javax.persistence.Id;
   import javax.persistence.JoinColumn;
   import javax.persistence.ManyToOne;
   import javax.persistence.Table;
   import java.time.LocalDate;
   import java.util.UUID;

   @Data
   @Entity
   @Table( name = "events" )
   public class EventEntity {

     @Id
     private UUID id;
     private LocalDate date;

   /**/@ManyToOne
   /**/@JoinColumn( name = "office", nullable = false )
   /**/private OfficeEntity office;

     public void addAttendee( final EventAttendeeEntity attendee ) {
     }
   }
   ```

   ```bash
   $ ./gradlew clean integrationTest "--tests" "*EventRepositoryTest"
   ...
   BUILD SUCCESSFUL in 9s
   6 actionable tasks: 6 executed
   ```

1. Add attendee

   Update file: `src/test-integration/java/demo/boot/event/EventRepositoryTest.java`

   {% include custom/dose_not_compile.html %}

   ```java
   package demo.boot.event;

   import demo.boot.office.OfficeEntity;
   import org.junit.jupiter.api.DisplayName;
   import org.junit.jupiter.api.Test;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
   import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;

   import java.util.List;
   import java.util.Optional;
   import java.util.UUID;

   import static org.assertj.core.api.Assertions.assertThat;

   @DataJpaTest
   @DisplayName( "Event repository" )
   @AutoConfigureTestDatabase( replace = AutoConfigureTestDatabase.Replace.NONE )
   public class EventRepositoryTest {

     @Autowired
     private EventRepository repository;

     private static final OfficeEntity COLOGNE = new OfficeEntity(
       "ThoughtWorks Cologne",
       "Lichtstr. 43i, 50825 Cologne, Germany",
       "Germany",
       "+49 221 64 30 70 63",
       "contact-de@thoughtworks.com",
       "https://www.thoughtworks.com/locations/cologne"
     );

     @Test
     @DisplayName( "should return the hard coded event" )
     public void shouldReturnAll() { /* ... */ }

     @Test
     @DisplayName( "should add attendee to event" )
     public void shouldAddAttendeeToEvent() {
       final UUID eventId = UUID.fromString( "47705b9b-518b-4dc2-a517-3dbbcab13fe7" );
       final Optional<EventEntity> optional = repository.findById( eventId );
       assertThat( optional.isPresent() ).isTrue();
       final EventEntity event = optional.get();

       final EventAttendeeEntity attendee = new EventAttendeeEntity();
       attendee.setId( UUID.randomUUID() );
       attendee.setName( "Jade Attard" );
       attendee.setFoodPreference( FoodPreference.NO_FOOD );
       attendee.setEvent( event );
       event.addAttendee( attendee );

       final EventEntity saved = repository.save( event );
       final List<EventAttendeeEntity> attendees = saved.getAttendees();
       assertThat( attendees )
         .isNotNull()
         .contains( attendee );
     }
   }
   ```

   Update file: `src/main/java/demo/boot/event/EventAttendeeEntity.java`

   ```java
   package demo.boot.event;

   import lombok.AllArgsConstructor;
   import lombok.Data;
   import lombok.NoArgsConstructor;

   import javax.persistence.Entity;
   import javax.persistence.EnumType;
   import javax.persistence.Enumerated;
   import javax.persistence.Id;
   import javax.persistence.JoinColumn;
   import javax.persistence.ManyToOne;
   import javax.persistence.Table;
   import java.util.UUID;

   @Data
   /**/@Entity
   /**/@Table( name = "events_attendees" )
   @AllArgsConstructor
   @NoArgsConstructor
   public class EventAttendeeEntity {

   /**/@Id
     private UUID id;
     private String name;

   /**/@Enumerated( EnumType.STRING )
     private FoodPreference foodPreference;

   /**/@ManyToOne
   /**/@JoinColumn( name = "event", nullable = false )
     private EventEntity event;
   }
   ```

   Update file: `src/main/java/demo/boot/event/EventEntity.java`

   ```java
   package demo.boot.event;

   import demo.boot.office.OfficeEntity;
   import lombok.Data;

   import javax.persistence.CascadeType;
   import javax.persistence.Entity;
   import javax.persistence.Id;
   import javax.persistence.JoinColumn;
   import javax.persistence.ManyToOne;
   import javax.persistence.OneToMany;
   import javax.persistence.Table;
   import java.time.LocalDate;
   import java.util.ArrayList;
   import java.util.List;
   import java.util.UUID;

   @Data
   @Entity
   @Table( name = "events" )
   public class EventEntity {

     @Id
     private UUID id;
     private LocalDate date;

     @ManyToOne
     @JoinColumn( name = "office", nullable = false )
     private OfficeEntity office;

   /**/@OneToMany( mappedBy = "event", cascade = CascadeType.ALL )
   /**/private List<EventAttendeeEntity> attendees = new ArrayList<>();

     public void addAttendee( final EventAttendeeEntity attendee ) {
   /**/attendees.add( attendee );
     }
   }
   ```

   ```bash
   $ ./gradlew clean integrationTest "--tests" "*EventRepositoryTest"

   ...

   BUILD SUCCESSFUL in 8s
   6 actionable tasks: 6 executed
   ```

The repository is complete too. It retrieves the event from the database and is able to add attendees.

## Wire things together

If we run the integration tests, these will fail as our application is not yet wired up.  We need to annotate the service and repository.

1. Run integration test

   ```bash
   $ ./gradlew clean integrationTest

   ...

   BUILD FAILED in 17s
   6 actionable tasks: 6 executed
   ```

   The integration tests fail as the application cannot start.

   ```bash
   ...
   Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'demo.boot.event.EventRegistrationService' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}
     at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1716)
     at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1272)
     at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1226)
     at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885)
     at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789)
     ... 109 more
   ```

1. Add the `@Service` annotation

   Update file: `src/main/java/demo/boot/event/EventRegistrationService.java`

   ```java
   package demo.boot.event;

   import lombok.AllArgsConstructor;
   import org.springframework.stereotype.Service;

   import java.time.LocalDate;
   import java.util.Optional;

   /**/@Service
   @AllArgsConstructor
   public class EventRegistrationService { /* ... */ }
   ```

   Run the integration test again.  This time will fail because of another service.

   ```bash
   Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'demo.boot.event.UuidGeneratorService' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}
       at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1716)
     at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1272)
     at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1226)
     at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885)
     at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789)
     ... 123 more
   ```

1. Add the `@Service` annotation

   Update file: `src/main/java/demo/boot/event/UuidGeneratorService.java`

   ```java
   package demo.boot.event;

   import org.springframework.stereotype.Service;

   import java.util.UUID;

   /**/@Service
   public class UuidGeneratorService { /* ... */ }
   ```

   Run the integration tests.

   ```bash
   $ ./gradlew clean integrationTest

   ...

   BUILD SUCCESSFUL in 25s
   6 actionable tasks: 6 executed
   ```

   This time the integration test should all pass and our application should be able to start.
